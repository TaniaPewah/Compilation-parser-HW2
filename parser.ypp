%{
	#include "output.hpp"
	#include <iostream>
	#include <stdlib.h>
	

	using namespace std;

	extern int yylex();
	int yyerror(const char * message);
%}

%token ID
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%token VOID
%token COMMA
%token SC
%token ASSIGN
%token RETURN

%token IF
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token INT
%token BYTE
%token BOOL

%token BINOP
%token NUM
%token B
%token STRING

%token TRUE
%token FALSE
%token NOT
%token AND
%token OR

%token RELOP


%%

Program : Funcs { printProductionRule(0); }
		;

Funcs : { printProductionRule(1); }
	  | FuncDecl Funcs { printProductionRule(2); }
	  ;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { printProductionRule(3); }
		;

RetType : Type { printProductionRule(4); }
		| VOID { printProductionRule(5); }
		;

Formals :  { printProductionRule(6); }
    | FormalsList { printProductionRule(7); }
    ;

FormalsList : FormalDecl { printProductionRule(8); }
			| FormalDecl COMMA FormalsList { printProductionRule(9); }
			;

FormalDecl : Type ID { printProductionRule(10); };
Statements : Statement { printProductionRule(11); }
		   | Statements Statement { printProductionRule(12); }
		   ;

Statement : LBRACE Statements RBRACE { printProductionRule(13); }
		  | Type ID SC { printProductionRule(14); }
		  | Type ID ASSIGN Exp SC { printProductionRule(15); }
		  | ID ASSIGN Exp SC { printProductionRule(16); }
		  | Call SC { printProductionRule(17); }
		  | RETURN SC { printProductionRule(18); }
		  | RETURN Exp SC { printProductionRule(19); }
		  | IF LPAREN Exp RPAREN Statement { printProductionRule(20); }
		  | IF LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(21); }
		  | WHILE LPAREN Exp RPAREN Statement{ printProductionRule(22); }
		  | WHILE LPAREN Exp RPAREN Statement ELSE Statement { printProductionRule(23); }
		  | BREAK SC { printProductionRule(24); }
		  | CONTINUE SC { printProductionRule(25); }
		  ;

Call : ID LPAREN ExpList RPAREN { printProductionRule(26); }
	 | ID LPAREN RPAREN { printProductionRule(27); }
	 ;

ExpList : Exp { printProductionRule(28); }
		| Exp COMMA ExpList { printProductionRule(29); }
		;

		
Type	: INT { printProductionRule(30); }
		| BYTE { printProductionRule(31); }
		| BOOL { printProductionRule(32); }
		;

Exp : LPAREN Exp RPAREN { printProductionRule(33); }
	| Exp BINOP Exp { printProductionRule(34); }
	| ID { printProductionRule(35); }
	| Call { printProductionRule(36); }
	| NUM { printProductionRule(37); }
	| NUM B { printProductionRule(38); }
	| STRING { printProductionRule(39); }
	| TRUE { printProductionRule(40); }
	| FALSE { printProductionRule(41); }
	| NOT Exp { printProductionRule(42); }
	| Exp AND Exp { printProductionRule(43); }
	| Exp OR Exp { printProductionRule(44); }
	| Exp RELOP Exp { $$.value = $1.value;
					  printProductionRule(45); }
	;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
