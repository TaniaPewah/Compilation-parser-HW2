%{
	#include "output.hpp"
	#include <iostream>
	#include <stdlib.h>
	typedef enum { OP_AND, OP_OR } opType;

	using namespace std;

	extern int yylex();
	int yyerror(const char * message);
%}

%token ID
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%token VOID
%token COMMA
%token 𝑆C
%token 𝐴𝑆𝑆𝐼𝐺𝑁
%token RETURN

%token 𝐼𝐹
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token INT
%token BYTE
%token BOOL




%%

Program : Funcs { printProductionRule(0); }
		;

Funcs : %empty{ printProductionRule(1); }
	  | FuncDecl Funcs { printProductionRule(2); }
	  ;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { printProductionRule(3); }
		;

RetType : Type { printProductionRule(4); }
		| VOID { printProductionRule(5); }
		;

Formals :  { printProductionRule(6); }
    | FormalsList { printProductionRule(7); }
    ;

FormalsList : FormalDecl { printProductionRule(8); }
			| FormalDecl COMMA FormalsList { printProductionRule(9); }
			;

FormalDecl : Type ID { printProductionRule(10); };
Statements : Statement { printProductionRule(11); }
		   | Statements Statement { printProductionRule(12); }
		   ;

Statement : 𝐿𝐵𝑅𝐴𝐶𝐸 𝑆𝑡𝑎𝑡𝑒𝑚𝑒𝑛𝑡𝑠 𝑅𝐵𝑅𝐴𝐶E { printProductionRule(13); }
		  | 𝑇𝑦𝑝𝑒 𝐼𝐷 𝑆C { printProductionRule(14); }
		  | 𝑇𝑦𝑝𝑒 𝐼𝐷 𝐴𝑆𝑆𝐼𝐺𝑁 𝐸𝑥𝑝 𝑆C { printProductionRule(15); }
		  | 𝐼𝐷 𝐴𝑆𝑆𝐼𝐺𝑁 𝐸𝑥𝑝 𝑆C { printProductionRule(16); }
		  | Call SC { printProductionRule(17); }
		  | RETURN SC { printProductionRule(18); }
		  | RETURN Exp SC { printProductionRule(19); }
		  | 𝐼𝐹 𝐿𝑃𝐴𝑅𝐸𝑁 𝐸𝑥𝑝 𝑅𝑃𝐴𝑅𝐸𝑁 𝑆𝑡𝑎𝑡𝑒𝑚𝑒𝑛t { printProductionRule(20); }
		  | 𝐼𝐹 𝐿𝑃𝐴𝑅𝐸𝑁 𝐸𝑥𝑝 𝑅𝑃𝐴𝑅𝐸𝑁 𝑆𝑡𝑎𝑡𝑒𝑚𝑒𝑛𝑡 𝐸𝐿𝑆𝐸 𝑆𝑡𝑎𝑡𝑒𝑚𝑒𝑛𝑡 { printProductionRule(21); }
		  | 𝑊𝐻𝐼𝐿𝐸 𝐿𝑃𝐴𝑅𝐸𝑁 𝐸𝑥𝑝 𝑅𝑃𝐴𝑅𝐸𝑁 𝑆𝑡𝑎𝑡𝑒𝑚𝑒𝑛t{ printProductionRule(22); }
		  | 𝑊𝐻𝐼𝐿𝐸 𝐿𝑃𝐴𝑅𝐸𝑁 𝐸𝑥𝑝 𝑅𝑃𝐴𝑅𝐸𝑁 𝑆𝑡𝑎𝑡𝑒𝑚𝑒𝑛𝑡 𝐸𝐿𝑆𝐸 𝑆𝑡𝑎𝑡𝑒𝑚𝑒𝑛t { printProductionRule(23); }
		  | BREAK SC { printProductionRule(24); }
		  | CONTINUE SC { printProductionRule(25); }
		  ;

Call : 𝐼𝐷 𝐿𝑃𝐴𝑅𝐸𝑁 𝐸𝑥𝑝𝐿𝑖𝑠𝑡 𝑅𝑃𝐴𝑅𝐸N { printProductionRule(26); }
	 | 𝐼𝐷 𝐿𝑃𝐴𝑅𝐸𝑁 𝑅𝑃𝐴𝑅𝐸N { printProductionRule(27); }
	 ;

ExpList : Exp { printProductionRule(28); }
		| Exp COMMA ExpList { printProductionRule(29); }
		;

		
Type	: INT { printProductionRule(30); }
		| BYTE { printProductionRule(31); }
		| BOOL { printProductionRule(32); }
		;

Exp : 𝐿𝑃𝐴𝑅𝐸𝑁 𝐸𝑥𝑝 𝑅𝑃𝐴𝑅𝐸N { printProductionRule(33); }
	| 𝐸𝑥𝑝 𝐵𝐼𝑁𝑂𝑃 𝐸𝑥𝑝 { printProductionRule(34); }
	| ID { printProductionRule(35); }
	| Call { printProductionRule(36); }
	| NUM { printProductionRule(37); }
	| NUM B { printProductionRule(38); }
	| SRING { printProductionRule(39); }
	| TRUE { printProductionRule(40); }
	| FALSE { printProductionRule(41); }
	| NOT Exp { printProductionRule(42); }
	| 𝐸𝑥𝑝 𝐴𝑁𝐷 𝐸𝑥𝑝 { printProductionRule(43); }
	| 𝐸𝑥𝑝 𝑂𝑅 𝐸𝑥𝑝 { printProductionRule(44); }
	| 𝐸𝑥𝑝 𝑅𝐸𝐿𝑂𝑃 𝐸𝑥𝑝 { $$.value = $1.value;
					  printProductionRule(45); }
	;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
