%{
	#include "output.hpp"
	#include <iostream>
	#include <stdlib.h>
	

	using namespace std;

	extern int yylex();
	int yyerror(const char * message);
%}

%nonassoc ID
%token LPAREN
%nonassoc RPAREN
%nonassoc LBRACE
%nonassoc RBRACE
%token VOID
%token COMMA
%token SC
%token ASSIGN
%nonassoc RETURN

%nonassoc IF
%nonassoc ELSE
%nonassoc WHILE
%nonassoc BREAK
%nonassoc CONTINUE
%nonassoc INT
%nonassoc BYTE
%nonassoc BOOL

%right BINOP
%token NUM
%token B
%token STRING

%token TRUE
%token FALSE
%left NOT
%right AND
%right OR

%right RELOP


%%

Program : Funcs { printProductionRule(0); }
		;

Funcs : { printProductionRule(1); }
	  | FuncDecl Funcs { printProductionRule(2); }
	  ;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { printProductionRule(3); }
		;

RetType : Type { printProductionRule(4); }
		| VOID { printProductionRule(5); }
		;

Formals :  { printProductionRule(6); }
    | FormalsList { printProductionRule(7); }
    ;

FormalsList : FormalDecl { printProductionRule(8); }
			| FormalDecl COMMA FormalsList { printProductionRule(9); }
			;

FormalDecl : Type ID { printProductionRule(10); };
Statements : Statement { printProductionRule(11); }
		   | Statements Statement { printProductionRule(12); }
		   | if_while_statment
		   ;

Statement : LBRACE Statements RBRACE { printProductionRule(13); }
		  | Type ID SC { printProductionRule(14); }
		  | Type ID ASSIGN Exp SC { printProductionRule(15); }
		  | ID ASSIGN Exp SC { printProductionRule(16); }
		  | Call SC { printProductionRule(17); }
		  | RETURN SC { printProductionRule(18); }
		  | RETURN Exp SC { printProductionRule(19); }
		  | BREAK SC { printProductionRule(24); }
		  | CONTINUE SC { printProductionRule(25); }
		  ;

Call : ID LPAREN ExpList RPAREN { printProductionRule(26); }
	 | ID LPAREN RPAREN { printProductionRule(27); }
	 ;

ExpList : Exp { printProductionRule(28); }
		| Exp COMMA ExpList { printProductionRule(29); }
		;

		
Type	: INT { printProductionRule(30); }
		| BYTE { printProductionRule(31); }
		| BOOL { printProductionRule(32); }
		;

Exp : LPAREN Exp RPAREN { printProductionRule(33); }
	| Exp BINOP Exp { printProductionRule(34); }
	| ID { printProductionRule(35); }
	| Call { printProductionRule(36); }
	| NUM { printProductionRule(37); }
	| NUM B { printProductionRule(38); }
	| STRING { printProductionRule(39); }
	| TRUE { printProductionRule(40); }
	| FALSE { printProductionRule(41); }
	| NOT Exp { printProductionRule(42); }
	| Exp AND Exp { printProductionRule(43); }
	| Exp OR Exp { printProductionRule(44); }
	| Exp RELOP Exp { $$.value = $1.value;
					  printProductionRule(45); }
	;


if_while_statment: open_statement
         | closed_statement
         ;

open_statement: IF LPAREN Exp RPAREN closed_statement { printProductionRule(20); }
              | IF LPAREN Exp RPAREN open_statement
              | IF LPAREN Exp RPAREN closed_statement ELSE open_statement
			  | WHILE LPAREN Exp RPAREN closed_statement  { printProductionRule(22); }
              | WHILE LPAREN Exp RPAREN open_statement
			  | WHILE LPAREN Exp RPAREN closed_statement ELSE open_statement
              ;

closed_statement: Statement
                | IF LPAREN Exp RPAREN closed_statement ELSE closed_statement { printProductionRule(21); }
                | WHILE LPAREN Exp RPAREN closed_statement ELSE closed_statement  { printProductionRule(23); }
                ;


%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
