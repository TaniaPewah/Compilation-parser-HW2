%{
	#include "output.hpp"
	#include <iostream>
	#include <stdlib.h>
	typedef enum { OP_AND, OP_OR } opType;

	using namespace std;

	extern int yylex();
	int yyerror(const char * message);
%}

%token ID
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%token VOID
%token COMMA
%token ğ‘†C
%token ğ´ğ‘†ğ‘†ğ¼ğºğ‘
%token RETURN

%token ğ¼ğ¹
%token ELSE
%token WHILE
%token BREAK
%token CONTINUE
%token INT
%token BYTE
%token BOOL




%%

Program : Funcs { printProductionRule(0); }
		;

Funcs : %empty{ printProductionRule(1); }
	  | FuncDecl Funcs { printProductionRule(2); }
	  ;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { printProductionRule(3); }
		;

RetType : Type { printProductionRule(4); }
		| VOID { printProductionRule(5); }
		;

Formals :  { printProductionRule(6); }
    | FormalsList { printProductionRule(7); }
    ;

FormalsList : FormalDecl { printProductionRule(8); }
			| FormalDecl COMMA FormalsList { printProductionRule(9); }
			;

FormalDecl : Type ID { printProductionRule(10); };
Statements : Statement { printProductionRule(11); }
		   | Statements Statement { printProductionRule(12); }
		   ;

Statement : ğ¿ğµğ‘…ğ´ğ¶ğ¸ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ğ‘  ğ‘…ğµğ‘…ğ´ğ¶E { printProductionRule(13); }
		  | ğ‘‡ğ‘¦ğ‘ğ‘’ ğ¼ğ· ğ‘†C { printProductionRule(14); }
		  | ğ‘‡ğ‘¦ğ‘ğ‘’ ğ¼ğ· ğ´ğ‘†ğ‘†ğ¼ğºğ‘ ğ¸ğ‘¥ğ‘ ğ‘†C { printProductionRule(15); }
		  | ğ¼ğ· ğ´ğ‘†ğ‘†ğ¼ğºğ‘ ğ¸ğ‘¥ğ‘ ğ‘†C { printProductionRule(16); }
		  | Call SC { printProductionRule(17); }
		  | RETURN SC { printProductionRule(18); }
		  | RETURN Exp SC { printProductionRule(19); }
		  | ğ¼ğ¹ ğ¿ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ¸ğ‘¥ğ‘ ğ‘…ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›t { printProductionRule(20); }
		  | ğ¼ğ¹ ğ¿ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ¸ğ‘¥ğ‘ ğ‘…ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ ğ¸ğ¿ğ‘†ğ¸ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ { printProductionRule(21); }
		  | ğ‘Šğ»ğ¼ğ¿ğ¸ ğ¿ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ¸ğ‘¥ğ‘ ğ‘…ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›t{ printProductionRule(22); }
		  | ğ‘Šğ»ğ¼ğ¿ğ¸ ğ¿ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ¸ğ‘¥ğ‘ ğ‘…ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›ğ‘¡ ğ¸ğ¿ğ‘†ğ¸ ğ‘†ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘’ğ‘›t { printProductionRule(23); }
		  | BREAK SC { printProductionRule(24); }
		  | CONTINUE SC { printProductionRule(25); }
		  ;

Call : ğ¼ğ· ğ¿ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ¸ğ‘¥ğ‘ğ¿ğ‘–ğ‘ ğ‘¡ ğ‘…ğ‘ƒğ´ğ‘…ğ¸N { printProductionRule(26); }
	 | ğ¼ğ· ğ¿ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ‘…ğ‘ƒğ´ğ‘…ğ¸N { printProductionRule(27); }
	 ;

ExpList : Exp { printProductionRule(28); }
		| Exp COMMA ExpList { printProductionRule(29); }
		;

		
Type	: INT { printProductionRule(30); }
		| BYTE { printProductionRule(31); }
		| BOOL { printProductionRule(32); }
		;

Exp : ğ¿ğ‘ƒğ´ğ‘…ğ¸ğ‘ ğ¸ğ‘¥ğ‘ ğ‘…ğ‘ƒğ´ğ‘…ğ¸N { printProductionRule(33); }
	| ğ¸ğ‘¥ğ‘ ğµğ¼ğ‘ğ‘‚ğ‘ƒ ğ¸ğ‘¥ğ‘ { printProductionRule(34); }
	| ID { printProductionRule(35); }
	| Call { printProductionRule(36); }
	| NUM { printProductionRule(37); }
	| NUM B { printProductionRule(38); }
	| SRING { printProductionRule(39); }
	| TRUE { printProductionRule(40); }
	| FALSE { printProductionRule(41); }
	| NOT Exp { printProductionRule(42); }
	| ğ¸ğ‘¥ğ‘ ğ´ğ‘ğ· ğ¸ğ‘¥ğ‘ { printProductionRule(43); }
	| ğ¸ğ‘¥ğ‘ ğ‘‚ğ‘… ğ¸ğ‘¥ğ‘ { printProductionRule(44); }
	| ğ¸ğ‘¥ğ‘ ğ‘…ğ¸ğ¿ğ‘‚ğ‘ƒ ğ¸ğ‘¥ğ‘ { $$.value = $1.value;
					  printProductionRule(45); }
	;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
